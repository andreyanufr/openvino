# Copyright (C) 2020-2022 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

from functools import partial
from bisect import bisect_left

import numpy as np
from ..function_selector import ACTIVATIONS_STATS_FN, PERTENSOR, PERCHANNEL

compute_act_stats_fn_per_tensor = ACTIVATIONS_STATS_FN['compute_statistic'][PERTENSOR]
compute_act_stats_fn_per_channel = ACTIVATIONS_STATS_FN['compute_statistic'][PERCHANNEL]

get_act_stats_fn_per_tensor = ACTIVATIONS_STATS_FN['statistic_in_graph'][PERTENSOR]
get_act_stats_fn_per_channel = ACTIVATIONS_STATS_FN['statistic_in_graph'][PERCHANNEL]


# helper functions to calculate statistics for activations
def calculate_per_channel_stats(acts, fn, axis=1):
    """ Calculates per-channel statistics for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-channel statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 3:
        return acts
    acts = np.moveaxis(acts, axis, 1)
    t = acts.reshape(acts.shape[0], acts.shape[1], -1)
    return fn(t, axis=2)


def calculate_per_tensor_stats(acts, fn):
    """ Calculates statistics by whole tensor for activations using a specific function
    :param act: activation
    :param fn: function to calculate per-tensor statistics
    :return statistics generated by fn for each activation in the batch
    """
    if len(acts.shape) < 2:
        return np.atleast_1d(fn(acts))

    t = acts.reshape(acts.shape[0], -1)
    return fn(t, axis=1)


@compute_act_stats_fn_per_tensor.register('max')
def max_per_tensor(acts, **_):
    return calculate_per_tensor_stats(acts, np.max)


@compute_act_stats_fn_per_tensor.register('min')
def min_per_tensor(acts, **_):
    return calculate_per_tensor_stats(acts, np.min)


@compute_act_stats_fn_per_tensor.register('abs_max')
def abs_max_per_tensor(acts, **_):
    return max_per_tensor(np.abs(acts))


@compute_act_stats_fn_per_tensor.register('quantile')
def quantile_per_tensor(acts, q, **_):
    return calculate_per_tensor_stats(acts, partial(np.quantile, q=q))


@compute_act_stats_fn_per_tensor.register('abs_quantile')
def abs_quantile_per_tensor(acts, q, **_):
    return quantile_per_tensor(np.abs(acts), q)


@compute_act_stats_fn_per_channel.register('mean')
def mean_per_channel(acts, **_):
    return calculate_per_channel_stats(acts, np.mean)


@compute_act_stats_fn_per_channel.register('mean_axis')
def mean_per_channel_axis(acts, layer_key=None, **kwargs):
    axis = kwargs.get('channel', {}).get(layer_key, 1)
    return calculate_per_channel_stats(acts, np.mean, axis=axis)


@compute_act_stats_fn_per_channel.register('quantile')
def quantile_per_channel(acts, q, **_):
    return calculate_per_channel_stats(acts, partial(np.quantile, q=q))


@compute_act_stats_fn_per_channel.register('max')
def max_per_channel(acts, **_):
    return calculate_per_channel_stats(acts, np.max)


@compute_act_stats_fn_per_channel.register('min')
def min_per_channel(acts, **_):
    return calculate_per_channel_stats(acts, np.min)


@compute_act_stats_fn_per_channel.register('abs_max')
def abs_max_per_channel(acts, **_):
    return max_per_channel(np.abs(acts))


@compute_act_stats_fn_per_channel.register('abs_quantile')
def abs_quantile_per_channel(acts, q, **_):
    return quantile_per_channel(np.abs(acts), q)


@get_act_stats_fn_per_tensor.register('max')
def get_max_per_tensor(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_tensor.register('min')
def get_min_per_tensor(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_tensor.register('abs_max')
def get_abs_max_per_tensor(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_channel.register('mean')
def get_mean_per_channel(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_channel.register('mean_axis')
def get_mean_per_channel_axis(acts, _, **__):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_channel.register('max')
def get_max_per_channel(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_channel.register('min')
def get_min_per_channel(acts, **_):
    return np.atleast_1d(acts)


@get_act_stats_fn_per_channel.register('abs_max')
def get_abs_max_per_channel(acts, **_):
    return np.atleast_1d(acts)


def find_closest(arr, num):
    pos = bisect_left(arr, num)
    if pos == 0:
        return arr[0]
    if pos == len(arr):
        return arr[-1]
    before = arr[pos - 1]
    after = arr[pos]
    if after - num < num - before:
        return after
    else:
        return before


def find_closest_quantize(quants, data):
    res = [0] * len(data)
    for i, val in enumerate(data):
        res[i] = find_closest(quants, val)
    return res


def mse_scale(x, axis=2):
    hf8_abs_quants = [0.0, 0.00012207, 0.000244141, 0.000366211, 0.000488281,
                     0.000610352, 0.000732422, 0.000854492, 0.000976562, 0.00109863, 0.0012207, 0.00134277, 0.00146484, 0.00158691,
                     0.00170898, 0.00183105, 0.00195312, 0.00219727, 0.00244141, 0.00268555, 0.00292969, 0.00317383, 0.00341797,
                     0.00366211, 0.00390625, 0.00439453, 0.00488281, 0.00537109, 0.00585938, 0.00634766, 0.00683594, 0.00732422,
                     0.0078125, 0.00878906, 0.00976562, 0.0107422, 0.0117188, 0.0126953, 0.0136719, 0.0146484, 0.015625, 0.0175781,
                     0.0195312, 0.0214844, 0.0234375, 0.0253906, 0.0273438, 0.0292969, 0.03125, 0.0351562, 0.0390625, 0.0429688,
                     0.046875, 0.0507812, 0.0546875, 0.0585938, 0.0625, 0.0703125, 0.078125, 0.0859375, 0.09375, 0.101562, 0.109375,
                     0.117188, 0.125, 0.140625, 0.15625, 0.171875, 0.1875, 0.203125, 0.21875, 0.234375, 0.25, 0.28125, 0.3125, 0.34375,
                     0.375, 0.40625, 0.4375, 0.46875, 0.5, 0.5625, 0.625, 0.6875, 0.75, 0.8125, 0.875, 0.9375, 1.0, 1.125, 1.25, 1.375,
                     1.5, 1.625, 1.75, 1.875, 2.0, 2.25, 2.5, 2.75, 3.0, 3.25, 3.5, 3.75, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0,
                     9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0]

    x = np.abs(x)
    sz = x.shape[axis]
    ln = len(x.shape)
    res_shape = [1] * ln
    res_shape[axis] = sz
    res = [1.0] * sz

    for i in range(sz):
        layer = x.take(indices=i, axis=axis).flatten()
        s = hf8_abs_quants[-1] / (np.max(layer) + np.finfo(float).eps)
        y = find_closest_quantize(hf8_abs_quants, s * layer)
        scale = np.mean(y) / np.mean(layer) # (s * x - y)**2 -> 0 =>
        res[i] = scale * s
    res = np.broadcast_to(np.array(res), res_shape)
    return res


@compute_act_stats_fn_per_channel.register('mse_scale')
def mse_scale_per_channel(acts, **_):
    return calculate_per_channel_stats(acts, mse_scale)
